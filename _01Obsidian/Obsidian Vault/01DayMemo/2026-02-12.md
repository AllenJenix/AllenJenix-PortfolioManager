# 🛠️ Portfolio Manager Project Log

## 📅 Last Updated: 2026-02-14
## 📂 System Architecture (Refactored)
*단일 스크립트(Notebook) 환경에서 모듈형 Layered Architecture로 시스템 구조를 전면 개편함.*

1.  **Global Config (`config.py`)**: 프로젝트 경로, 파일명 매핑, 인코딩 상수 중앙 관리
2.  **Layer 1: Data Loaders (`data_loaders/`)**
    * **`io.py`**: `cp949`/`utf-8` 인코딩 자동 감지 및 폴더 자동 생성 유틸리티
    * **`parser.py`**: HTS 원본(비정형) → 표준 CSV(정형) 변환 (2줄 병합, 노이즈 필터링)
3.  **Layer 2: Calculation Engines (`engines/`)**: (구현 예정) 원장 생성 및 성과 분석
4.  **Layer 3: UI/Reporting (`ui/`)**: (구현 예정) 시각화 및 리포트

## 🛠️ Development Log (금일 개발 요약)
### 1. Project Structure & Convention
- [x] **Refactoring**: `01DATA`, `02src` 구조로 분리하여 데이터와 코드의 의존성 제거
- [x] **Convention**: `CODING_CONVENTION.md` 수립 (Type Hinting, Docstring, 이모지 로그 표준화)
- [x] **Config**: 하드코딩된 경로를 제거하고 `pathlib` 기반의 동적 경로 시스템 구축

### 2. Data Pipeline Implementation (Layer 1)
- [x] **Smart I/O**: `UnicodeDecodeError` 발생 시 자동으로 인코딩을 전환하여 재시도하는 로직 구현 (`io.py`)
- [x] **Logic Porting**: 기존 Notebook(`TEST.ipynb`)의 검증된 파싱 로직(Header Mapping, Multi-line processing)을 `parser.py`로 완벽 이식
- [x] **Bug Fix**: 파이썬 패키지 명명 규칙 위반(`01data_loaders`) 및 표준 라이브러리 충돌(`import io`) 문제 해결
- [x] **Data Cleaning**: HTS 출력물 하단의 "감사합니다/출력 완료" 등 불필요한 메타데이터 행(Row) 필터링 강화

## 🚀 Technical Achievement (개발 성과 KPI)
| 항목 | 상태/수치 | 비고 |
| :--- | :--- | :--- |
| **시스템 모듈화** | **Layered Arch** | Config / Loader / Engine / UI 계층 분리 성공 |
| **데이터 정합성** | **Legacy 100%** | 기존 Notebook의 파싱 결과와 바이트 단위까지 동일한 출력값 확보 |
| **에러 내성** | **Auto-Recovery** | 인코딩 에러, 누락된 폴더, 비정형 헤더에 대한 예외 처리 완비 |
| **유지보수성** | **Single Source** | `config.py` 수정만으로 전체 파일 경로 및 설정 변경 가능 |

## 💡 Engineering Insights (기술적 통찰)
- **네임스페이스 충돌(Namespace Collision)**: 모듈명을 `io.py`로 지었을 때 파이썬 내장 라이브러리 `io`와 충돌하여 `AttributeError`가 발생함. → 내부 모듈 호출 시 `local_io`와 같이 별칭(Alias)을 사용하여 명시적으로 구분해야 함.
- **패키지 명명 규칙(Naming Rule)**: 폴더명 앞에 숫자(`01data_loaders`)를 붙이면 파이썬이 패키지로 인식하지 못해 `ImportError` 발생. → 소스 코드 디렉토리는 반드시 영문자로 시작해야 함을 재확인.
- **의존성 방향 원칙**: `io`나 `parser` 같은 하위 모듈은 상위 비즈니스 로직(`engine`)을 참조하면 안 됨. (Circular Import 방지)
- **레거시 로직의 중요성**: "코드를 예쁘게 짜는 것"보다 중요한 것은 "기존의 정확한 결과값(Domain Logic)을 유지하는 것"임. 리팩토링 과정에서 노트북의 투박한 로직을 섣불리 단순화했다가 데이터 누락 발생 → 원복 후 최적화 진행.